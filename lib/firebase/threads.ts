import {
  collection,
  doc,
  addDoc,
  updateDoc,
  getDocs,
  query,
  orderBy,
  limit,
  onSnapshot,
  Timestamp,
  getDoc,
  where,
  arrayUnion,
} from 'firebase/firestore'
import { db } from './config'
import { Thread, User, Comment } from '@/data/sampleThreads'
import { threadToFirestore, firestoreToThread, commentToFirestore } from './converters'
import { getUserProfile } from './users'

// Create a new thread
export const createThread = async (threadData: Omit<Thread, 'id' | 'createdAt'>): Promise<string> => {
  if (!db) throw new Error('Firebase Firestore not initialized')

  const threadsRef = collection(db, 'threads')
  const firestoreData = threadToFirestore({
    ...threadData,
    id: '', // Will be generated by Firestore
    createdAt: new Date(),
  } as Thread)

  // Remove id from data (Firestore will generate it)
  const { id, ...dataWithoutId } = firestoreData as any

  const docRef = await addDoc(threadsRef, dataWithoutId)
  return docRef.id
}

// Update thread with image URL
export const updateThreadImage = async (threadId: string, imageUrl: string) => {
  if (!db) throw new Error('Firebase Firestore not initialized')

  const threadRef = doc(db, 'threads', threadId)
  await updateDoc(threadRef, {
    image: imageUrl,
  })
}

// Get all threads (initial fetch)
export const getThreads = async (): Promise<Thread[]> => {
  if (!db) throw new Error('Firebase Firestore not initialized')

  const threadsRef = collection(db, 'threads')
  const q = query(threadsRef, orderBy('createdAt', 'desc'))
  const querySnapshot = await getDocs(q)

  const threads: Thread[] = []
  const authorIds = new Set<string>()

  // Collect all unique author IDs
  querySnapshot.forEach((doc) => {
    const data = doc.data()
    if (data.authorId) {
      authorIds.add(data.authorId)
    }
  })

  // Fetch all authors
  const authorsMap = new Map<string, User>()
  await Promise.all(
    Array.from(authorIds).map(async (authorId) => {
      const author = await getUserProfile(authorId)
      if (author) {
        authorsMap.set(authorId, author)
      }
    })
  )

  // Convert documents to Thread objects
  querySnapshot.forEach((doc) => {
    const data = doc.data()
    const author = authorsMap.get(data.authorId) || {
      id: data.authorId,
      username: 'unknown',
      avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=unknown',
    } as User

    threads.push(firestoreToThread({ id: doc.id, ...data }, author))
  })

  return threads
}

// Real-time listener for threads
export const subscribeToThreads = (
  callback: (threads: Thread[]) => void,
  onError?: (error: Error) => void
) => {
  if (!db) return () => { }

  const threadsRef = collection(db, 'threads')
  const q = query(threadsRef, orderBy('createdAt', 'desc'))

  const unsubscribe = onSnapshot(
    q,
    async (querySnapshot) => {
      try {
        const threads: Thread[] = []
        const authorIds = new Set<string>()

        // Collect all unique author IDs
        querySnapshot.forEach((doc) => {
          const data = doc.data()
          if (data.authorId) {
            authorIds.add(data.authorId)
          }
        })

        // Fetch all authors
        const authorsMap = new Map<string, User>()
        await Promise.all(
          Array.from(authorIds).map(async (authorId) => {
            const author = await getUserProfile(authorId)
            if (author) {
              authorsMap.set(authorId, author)
            }
          })
        )

        // Convert documents to Thread objects
        querySnapshot.forEach((doc) => {
          const data = doc.data()
          const author = authorsMap.get(data.authorId) || {
            id: data.authorId,
            username: 'unknown',
            avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=unknown',
          } as User

          threads.push(firestoreToThread({ id: doc.id, ...data }, author))
        })

        callback(threads)
      } catch (error) {
        console.error('Error processing threads:', error)
        if (onError) {
          onError(error as Error)
        }
      }
    },
    (error) => {
      console.error('Error listening to threads:', error)
      if (onError) {
        onError(error as Error)
      }
    }
  )

  return unsubscribe
}

// Get a single thread by ID
export const getThread = async (threadId: string): Promise<Thread | null> => {
  if (!db) throw new Error('Firebase Firestore not initialized')

  const threadRef = doc(db, 'threads', threadId)
  const threadSnap = await getDoc(threadRef)

  if (!threadSnap.exists()) {
    return null
  }

  const data = threadSnap.data()
  const author = await getUserProfile(data.authorId)

  if (!author) {
    return null
  }

  return firestoreToThread({ id: threadSnap.id, ...data }, author)
}

// Add a comment to a thread
export const addCommentToThread = async (threadId: string, comment: Comment) => {
  if (!db) throw new Error('Firebase Firestore not initialized')

  const threadRef = doc(db, 'threads', threadId)
  const commentData = commentToFirestore(comment)

  await updateDoc(threadRef, {
    comments: arrayUnion(commentData)
  })
}
